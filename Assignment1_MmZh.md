Assignment_B_1_Make_a_function
================

\#Load packages

``` r
library(datateachr)
library(ggplot2)
library(tidyverse)
```

    ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ## ✔ dplyr     1.1.3     ✔ readr     2.1.4
    ## ✔ forcats   1.0.0     ✔ stringr   1.5.0
    ## ✔ lubridate 1.9.2     ✔ tibble    3.2.1
    ## ✔ purrr     1.0.1     ✔ tidyr     1.3.0
    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

``` r
library(testthat) 
```

    ## 
    ## Attaching package: 'testthat'
    ## 
    ## The following object is masked from 'package:dplyr':
    ## 
    ##     matches
    ## 
    ## The following object is masked from 'package:purrr':
    ## 
    ##     is_null
    ## 
    ## The following objects are masked from 'package:readr':
    ## 
    ##     edition_get, local_edition
    ## 
    ## The following object is masked from 'package:tidyr':
    ## 
    ##     matches

``` r
library(dplyr) 
```

\#Exercise 1: Make a Function & Exercise 2:Document your Function \#I
hope to develop a function that can export the range of selected column
by simply typing in the column names,at the same time provide how many
NA in that column \#I will use the cancer_sample data as example

``` r
#' @title   Data_Range
#' @description  This function can compute the range of a column by using the column name from a dataset
#' @param data  A data frame that contains the interested numeric data under certain column
#' @param Col_name A character in form of "column name"
#' @return A vector contains two values, the minimum and maximum of the selected column
#' @export

Data_Range <- function(data, Col_name) {
  if (Col_name %in% colnames(data)) {
    column <- data[[Col_name]]
    
    if (length(column) == 0) {
      # Handle an empty vector
      result_vector <- "Empty vector provided"
    } else {
      # Filter out non-numeric values (keep NA)
      valid_values <- column[is.na(column) | is.numeric(column)]
      
      if (length(valid_values) == 0) {
        # Handle the case where there are no valid numeric values
        result_vector <- "No valid numeric values in the column"
      } else {
        num_na <- sum(is.na(valid_values))
        range_value <- range(valid_values, na.rm = TRUE)  # Use na.rm to ignore NA values in range calculation
      
        result_vector <- c(paste("range=", paste(range_value, collapse=" to "), "number of NA=", num_na))
      }
    }
    
    return(result_vector)
  } else {
    stop("Column not found in the dataset")
  }
}


#' @examples
#' range_radius_mean <- Data_Range(cancer_sample, "radius_mean")
```

\#Exercise 3: Include examples \#Example 1: use dataset “cancer_sample”,
use Data_Range to find out the range for some columns

``` r
#show the minum and maximun values in "texture_mean" column in cancer_sample dataset
Data_Range(cancer_sample,"texture_mean")
```

    ## [1] "range= 9.71 to 39.28 number of NA= 0"

``` r
glimpse(Data_Range(cancer_sample,"texture_mean"))
```

    ##  chr "range= 9.71 to 39.28 number of NA= 0"

\#Example 1 works well, it turned out a vector including 2 values \#The
I can check whether those are the correct answer by checking in another
way:

``` r
cancer_sample%>%
  select(texture_mean)%>%
  mutate(min = min(texture_mean),
         max = max(texture_mean),
         num_na = sum(is.na(texture_mean)))
```

    ## # A tibble: 569 × 4
    ##    texture_mean   min   max num_na
    ##           <dbl> <dbl> <dbl>  <int>
    ##  1         10.4  9.71  39.3      0
    ##  2         17.8  9.71  39.3      0
    ##  3         21.2  9.71  39.3      0
    ##  4         20.4  9.71  39.3      0
    ##  5         14.3  9.71  39.3      0
    ##  6         15.7  9.71  39.3      0
    ##  7         20.0  9.71  39.3      0
    ##  8         20.8  9.71  39.3      0
    ##  9         21.8  9.71  39.3      0
    ## 10         24.0  9.71  39.3      0
    ## # ℹ 559 more rows

\#We can see that the result are the same as the one generated by our
Data_Range function

\#Example 2: Let’s take another dataset to use the function, we choose
vancouver_trees

``` r
diameter_range_Vtree<-Data_Range(vancouver_trees,"diameter")
paste(diameter_range_Vtree)
```

    ## [1] "range= 0 to 435 number of NA= 0"

\#For example 2, the Data_Range function still works well.

\#Exercise 4: Test the Function \#Test 1: if a numeric object is
returned for valid inputs

``` r
test_that("Data_Range calculates range for vector of numeric data without NA", {
  # Create a sample data frame with a numeric column without NA values
  data_frame <- data.frame(data_vector = c(1, 2, 3, 4, 5))

  # Call the Data_Range function on the sample data frame
  result <- Data_Range(data_frame, "data_vector")

  # Define the expected result based on manual calculation
  expected_result <- "range= 1 to 5 number of NA= 0"

  # Check if the result matches the expected result
  expect_equal(result, expected_result)
})
```

    ## Test passed 🌈

\#Test 2:Vector that has NA’s

``` r
test_that("Data_Range calculates range for vector of numeric data including NA", {
  # Create a sample data frame with a numeric column with NA values
  data_frame <- data.frame(data_vector = c(1, 2, NA, 4, NA))

  # Call the Data_Range function on the sample data frame
  result <- Data_Range(data_frame, "data_vector")

  # Define the corrected expected result, indicating that there are 2 NA values
  expected_result <- "range= 1 to 4 number of NA= 2"

  # Check if the result matches the corrected expected result
  expect_equal(result, expected_result)
})
```

    ## Test passed 😀

\#Test 3:Vector of length 0, like numeric(0)

``` r
test_that("Data_Range handles an empty vector correctly", {
  # Create an empty data frame with an empty numeric vector
  empty_data_frame <- data.frame(empty_vector = numeric(0))

  # Call the Data_Range function on the empty data frame
  result <- Data_Range(empty_data_frame, "empty_vector")

  # Define the expected result for an empty vector
  expected_result <- "Empty vector provided"

  # Check if the result matches the expected result
  expect_equal(result, expected_result)
})
```

    ## Test passed 😀
